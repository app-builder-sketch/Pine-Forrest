// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © DarkPoolCrypto

//@version=6
indicator("Apex Vector [Flux + Efficiency] v4.1", shorttitle="APEX Vector", overlay=false, precision=2, explicit_plot_zorder=true)

//──────────────────────────────────────────────────────────────────────────────
// SECTION: PHYSICS CONSTANTS (THE BRAIN)
//──────────────────────────────────────────────────────────────────────────────
const float DEF_EFF_SUPER  = 0.60
const float DEF_EFF_RESIST = 0.30

//──────────────────────────────────────────────────────────────────────────────
// SECTION: INPUTS - ENGINE
//──────────────────────────────────────────────────────────────────────────────
string G_PHYS = "Physics Engine (Advanced)"
float eff_super  = input.float(DEF_EFF_SUPER, "Superconductor Threshold", minval=0.1, maxval=1.0, step=0.05, group=G_PHYS)
float eff_resist = input.float(DEF_EFF_RESIST, "Resistive Threshold", minval=0.0, maxval=0.5, step=0.05, group=G_PHYS)
int   vol_norm   = input.int(55, "Volume Normalization", minval=10, group=G_PHYS)

string G_CALC = "Vector Calculations"
int   len_vec    = input.int(14, "Vector Length", minval=2, group=G_CALC)
string sm_type   = input.string("EMA", "Smoothing Type", options=["EMA", "SMA", "RMA", "WMA", "VWMA"], group=G_CALC)
int   len_sm     = input.int(5, "Smoothing Length", minval=1, group=G_CALC)
bool  use_vol    = input.bool(true, "Integrate Volume Flux", group=G_CALC)
float strictness = input.float(1.0, "Global Strictness", step=0.1, group=G_CALC)

//──────────────────────────────────────────────────────────────────────────────
// SECTION: INPUTS - DIVERGENCE
//──────────────────────────────────────────────────────────────────────────────
string G_DIV = "Divergence Engine"
bool show_div    = input.bool(true, "Show Divergences", group=G_DIV)
int  div_look    = input.int(5, "Pivot Lookback", minval=1, group=G_DIV)
bool show_reg    = input.bool(true, "Regular (Reversal)", group=G_DIV)
bool show_hid    = input.bool(false, "Hidden (Continuation)", group=G_DIV)

//──────────────────────────────────────────────────────────────────────────────
// SECTION: INPUTS - VISUALS
//──────────────────────────────────────────────────────────────────────────────
string G_VIS = "Visuals: Chart & Histogram"
bool show_bar    = input.bool(true, "Colorize Price Bars", group=G_VIS)
bool use_grad    = input.bool(true, "Gradient Intensity", group=G_VIS)

color c_super_up = input.color(#00E676, "Superconductor (Bull)", group=G_VIS)
color c_super_dn = input.color(#FF1744, "Superconductor (Bear)", group=G_VIS)
color c_resist   = input.color(#546E7A, "Resistive (Chop)", group=G_VIS)
color c_heat     = input.color(#FFD600, "High Heat (Warning)", group=G_VIS)
color c_div_bull = input.color(#00B0FF, "Div Bull", group=G_VIS)
color c_div_bear = input.color(#FF4081, "Div Bear", group=G_VIS)

string G_HUD = "Visuals: Heads-Up Display"
bool   hud_show    = input.bool(true, "Show HUD", group=G_HUD)
bool   hud_compact = input.bool(false, "Compact Mode", group=G_HUD)
string hud_pos     = input.string("Top Right", "Position", options=["Top Right", "Bottom Right", "Top Left", "Bottom Left"], group=G_HUD)
string hud_size    = input.string("Small", "Size", options=["Tiny", "Small", "Normal", "Large"], group=G_HUD)
color  hud_bg      = input.color(color.new(#000000, 20), "Background", group=G_HUD)
color  hud_txt     = input.color(color.new(#FFFFFF, 0), "Text", group=G_HUD)

//──────────────────────────────────────────────────────────────────────────────
// SECTION: CALCULATIONS
//──────────────────────────────────────────────────────────────────────────────
// 1. Geometric Efficiency
series float range_abs = high - low
series float body_abs  = math.abs(close - open)
series float raw_eff   = range_abs == 0 ? 0.0 : body_abs / range_abs
series float efficiency = ta.ema(raw_eff, len_vec)

// 2. Volume Flux
series float vol_avg   = ta.sma(volume, vol_norm)
series float vol_fact  = use_vol ? (vol_avg == 0 ? 1.0 : volume / vol_avg) : 1.0

// 3. The Apex Vector
series float direction  = math.sign(close - open)
series float vector_raw = direction * efficiency * vol_fact

// 4. Smoothing Kernel
float flux = switch sm_type
    "EMA"  => ta.ema(vector_raw, len_sm)
    "SMA"  => ta.sma(vector_raw, len_sm)
    "RMA"  => ta.rma(vector_raw, len_sm)
    "WMA"  => ta.wma(vector_raw, len_sm)
    "VWMA" => ta.vwma(vector_raw, len_sm)
    => ta.ema(vector_raw, len_sm)

//──────────────────────────────────────────────────────────────────────────────
// SECTION: LOGIC & STATE MACHINE
//──────────────────────────────────────────────────────────────────────────────
float th_super  = eff_super * strictness
float th_resist = eff_resist * strictness

bool is_super_bull = flux > th_super
bool is_super_bear = flux < -th_super
bool is_resistive  = math.abs(flux) < th_resist
bool is_heat       = not is_super_bull and not is_super_bear and not is_resistive

// Gradient Intensity
float flux_abs = math.abs(flux)
float safe_th = th_super == 0 ? 0.1 : th_super
float intensity_raw = is_resistive ? 30 : (flux_abs / safe_th) * 100
float intensity = math.min(intensity_raw, 95) 
float alpha_val = use_grad ? (100 - intensity) : 0

color base_col = is_super_bull ? c_super_up :
                 is_super_bear ? c_super_dn :
                 is_resistive  ? c_resist :
                 c_heat
color state_col = color.new(base_col, alpha_val)

//──────────────────────────────────────────────────────────────────────────────
// SECTION: DIVERGENCE ENGINE (FIXED)
//──────────────────────────────────────────────────────────────────────────────
// 1. Identify Pivots
float ph = ta.pivothigh(flux, div_look, div_look)
float pl = ta.pivotlow(flux, div_look, div_look)

// 2. Memory Variables (Stores the Previous Pivot Data)
var float prev_pl_flux  = na
var float prev_pl_price = na
var float prev_ph_flux  = na
var float prev_ph_price = na

// 3. Detection Logic
bool div_bull_reg = false
bool div_bull_hid = false
bool div_bear_reg = false
bool div_bear_hid = false

// Bullish Check
if not na(pl)
    // Get the price low corresponding to the flux pivot
    float price_at_pivot = low[div_look]
    
    if show_div and not na(prev_pl_flux)
        // Regular Bull: Lower Price, Higher Flux
        if price_at_pivot < prev_pl_price and pl > prev_pl_flux
            div_bull_reg := show_reg
        // Hidden Bull: Higher Price, Lower Flux
        if price_at_pivot > prev_pl_price and pl < prev_pl_flux
            div_bull_hid := show_hid
    
    // Update Memory
    prev_pl_flux  := pl
    prev_pl_price := price_at_pivot

// Bearish Check
if not na(ph)
    // Get the price high corresponding to the flux pivot
    float price_at_pivot = high[div_look]
    
    if show_div and not na(prev_ph_flux)
        // Regular Bear: Higher Price, Lower Flux
        if price_at_pivot > prev_ph_price and ph < prev_ph_flux
            div_bear_reg := show_reg
        // Hidden Bear: Lower Price, Higher Flux
        if price_at_pivot < prev_ph_price and ph > prev_ph_flux
            div_bear_hid := show_hid
            
    // Update Memory
    prev_ph_flux  := ph
    prev_ph_price := price_at_pivot

//──────────────────────────────────────────────────────────────────────────────
// SECTION: PLOTTING
//──────────────────────────────────────────────────────────────────────────────
hline(0, "Ground", color=color.new(color.gray, 50), linestyle=hline.style_dotted)

plot(flux, "Flux Vector", color=state_col, style=plot.style_columns, linewidth=1)

plotshape(div_bull_reg ? flux[div_look] : na, "Reg Bull", shape.circle, location.absolute, c_div_bull, offset=-div_look, size=size.tiny)
plotshape(div_bull_hid ? flux[div_look] : na, "Hid Bull", shape.cross, location.absolute, c_div_bull, offset=-div_look, size=size.tiny)
plotshape(div_bear_reg ? flux[div_look] : na, "Reg Bear", shape.circle, location.absolute, c_div_bear, offset=-div_look, size=size.tiny)
plotshape(div_bear_hid ? flux[div_look] : na, "Hid Bear", shape.cross, location.absolute, c_div_bear, offset=-div_look, size=size.tiny)

var line ln_upper = line.new(na, na, na, na, color=color.new(c_super_up, 80))
var line ln_lower = line.new(na, na, na, na, color=color.new(c_super_dn, 80))
line.set_xy1(ln_upper, bar_index, th_super)
line.set_xy2(ln_upper, bar_index + 10, th_super)
line.set_xy1(ln_lower, bar_index, -th_super)
line.set_xy2(ln_lower, bar_index + 10, -th_super)

color bar_tint = show_bar ? base_col : na
barcolor(bar_tint, title="Vector Bar Color")

//──────────────────────────────────────────────────────────────────────────────
// SECTION: HUD ENGINE
//──────────────────────────────────────────────────────────────────────────────
var table hud = na

string pos_const = switch hud_pos
    "Top Right"     => position.top_right
    "Top Left"      => position.top_left
    "Bottom Right"  => position.bottom_right
    "Bottom Left"   => position.bottom_left
    => position.top_right

string size_const = switch hud_size
    "Tiny"   => size.tiny
    "Small"  => size.small
    "Normal" => size.normal
    "Large"  => size.large
    => size.small

if hud_show and barstate.islast
    int rows = hud_compact ? 2 : 5
    if na(hud)
        hud := table.new(pos_const, 2, rows, bgcolor=hud_bg, frame_width=1, frame_color=color.new(color.gray, 50), border_width=1, border_color=color.new(color.gray, 80))
    
    string s_txt = is_super_bull ? "SUPER (BULL)" : (is_super_bear ? "SUPER (BEAR)" : (is_resistive ? "RESISTIVE" : "HIGH HEAT"))
    string div_status = div_bull_reg ? "Bull Reg" : (div_bear_reg ? "Bear Reg" : (div_bull_hid ? "Bull Hid" : (div_bear_hid ? "Bear Hid" : "None")))
    color div_col = (div_bull_reg or div_bull_hid) ? c_div_bull : ((div_bear_reg or div_bear_hid) ? c_div_bear : hud_txt)
    
    // Header
    table.cell(hud, 0, 0, "APEX VECTOR", text_color=hud_txt, text_size=size_const, text_halign=text.align_left)
    table.cell(hud, 1, 0, "v4.1",        text_color=color.gray,  text_size=size_const, text_halign=text.align_right)
    
    // State
    table.cell(hud, 0, 1, "STATE",       text_color=hud_txt, text_size=size_const, text_halign=text.align_left)
    table.cell(hud, 1, 1, s_txt,         text_color=base_col,    text_size=size_const, text_halign=text.align_right) 
    
    if not hud_compact
        table.cell(hud, 0, 2, "EFFICIENCY",  text_color=hud_txt, text_size=size_const, text_halign=text.align_left)
        table.cell(hud, 1, 2, str.tostring(efficiency * 100, "#") + "%", text_color=color.gray, text_size=size_const, text_halign=text.align_right)
        
        table.cell(hud, 0, 3, "FLUX",        text_color=hud_txt, text_size=size_const, text_halign=text.align_left)
        table.cell(hud, 1, 3, str.tostring(flux, "#.00"), text_color=base_col, text_size=size_const, text_halign=text.align_right)

        table.cell(hud, 0, 4, "DIV ALERT",   text_color=hud_txt, text_size=size_const, text_halign=text.align_left)
        table.cell(hud, 1, 4, div_status,    text_color=div_col,     text_size=size_const, text_halign=text.align_right)

//──────────────────────────────────────────────────────────────────────────────
// SECTION: ALERTS
//──────────────────────────────────────────────────────────────────────────────
// Static Alerts
alertcondition(is_super_bull and not is_super_bull[1], "Apex: Superconductor Bull", "Market Entered Bullish Superconductor")
alertcondition(is_super_bear and not is_super_bear[1], "Apex: Superconductor Bear", "Market Entered Bearish Superconductor")
alertcondition(div_bull_reg, "Apex: Bull Div", "Regular Bullish Divergence")
alertcondition(div_bear_reg, "Apex: Bear Div", "Regular Bearish Divergence")

// Dynamic Webhooks
if barstate.isconfirmed
    if is_super_bull and not is_super_bull[1]
        alert("Apex Vector: BULLISH Superconductor Triggered | Flux: " + str.tostring(flux) + " | Price: " + str.tostring(close), alert.freq_once_per_bar_close)
    if is_super_bear and not is_super_bear[1]
        alert("Apex Vector: BEARISH Superconductor Triggered | Flux: " + str.tostring(flux) + " | Price: " + str.tostring(close), alert.freq_once_per_bar_close)
    if is_heat and not is_heat[1]
        alert("Apex Vector: HIGH HEAT Warning (Possible Reversal) | Flux: " + str.tostring(flux), alert.freq_once_per_bar_close)
